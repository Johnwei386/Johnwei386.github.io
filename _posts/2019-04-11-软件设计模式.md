---
layout:     post
title:      软件设计模式
subtitle:   Software Architecture Patterns
date:       2019-04-11
author:     JW
header-img: img/jwblog/post-background-all.png
catalog: true
tags:
    - software 
    - architecture
    - patterns
---

## 介绍
对大多数开发者而言，确定软件的架构模式是所有软件开发任务的首要任务。大多数开发者首先会选择最经典的**分层架构**。一个缺乏合适架构的应用通常是**紧密耦合**的。本文所有内容皆参考 O'REILLY 出版的《[Software Architecture Patterns](https://www.oreilly.com/programming/free/files/software-architecture-patterns.pdf)》。

## 分层架构(Layered Architecture)

![](/img/jwblog/softArchi/figure1-1.png)

如**Figure 1-1**所示，它是一个分层架构的模型图，分层架构，顾名思义，应用的结构是一个层级结构，架构中的每一层有其对应的角色和责任。多数分层架构由四个标准的层定义：表示层(presentation),事务层(business),持久层(persistence)和存储层(database)。每一层皆有其对应的角色和责任，例如，表示层将处理与用户的交互，提供一个操作接口给用户；事务层将执行与与用户请求有关的业务逻辑。每一层只需要完成该层相关的业务逻辑，并不需要涉及其他层的业务，这将软件的功能和架构中的层结合起来，层与层之间不会产生事务逻辑上的重叠，层与层之间是相互独立的，修改某一层的逻辑，而不改变这一层提供给上一层的调用接口，将不会引起整个架构的更改。这使得应用很容易开发、调试、管理和维护。

![](/img/jwblog/softArchi/figure1-2.png)

*closed*是一个很重要的概念，如**Figure 1-2**所示，架构中的每一层都被标记为*closed*。*closed*的层表示，对于一个请求信息流而言，它必须一层接一层的向下传递，而不能跨层传递，比如，不允许表示层直接访问持久层。之所以不允许跨层访问是因为**层的隔离性(isolation)**。层的隔离性意味着架构中某一层的改变不会影响到其他层：这个改变被隔离了。如果让表示层可以直接访问持久层，那么对持久层的修改将会影响它的上层事务层和表示层，这将造成非常紧密的耦合关系，使得修改架构的代价变得及其昂贵。

![](/img/jwblog/softArchi/figure1-3.png)

封闭的层(*closed*)能有效的保证层与层之间的隔离性，但是对于某些应用场景，比如说，需要添加一个*共享服务层*到架构中，如**Figure 1-3**所示，在事务层的下面添加一个服务层，按照*closed*的概念，事务层将无法直接访问持久层，必须通过服务层来实现对持久层的访问。但是，事务层直接访问持久层能提升效率，通过某些中间层来实现访问是完全没有道理的，此时可以通过将新添加的服务层标记为*open*，这意味着来自上层的请求可以主动选择是否绕过该服务层，直接对其下面的层进行访问。这样就可以使事务层屏蔽掉服务层，然后直接对持久层进行访问。
