---
layout:     post
title:      软件设计模式
subtitle:   Software Architecture Patterns
date:       2019-04-11
author:     JW
header-img: img/post-bg-unix-linux.jpg
catalog: true
tags:
    - software 
    - architecture
    - patterns
---

# 介绍
对大多数开发者而言，确定软件的架构模式是所有软件开发任务的首要任务。大多数开发者首先会选择最经典的**分层架构**。一个缺乏合适架构的应用通常是**紧密耦合**的。本文所有内容皆参考 O'REILLY 出版的《[Software Architecture Patterns](https://www.oreilly.com/programming/free/files/software-architecture-patterns.pdf)》。

# 评估标准
针对不同的架构模式，有一些业界公认的评估标准，为评估和改进软件架构提供了一个参考标准：
1. 整体敏捷性(Overall agility):整体敏捷性是指对一个不断变化的环境的快速反应能力。
2. 易部署性(Ease of deployment)
3. 可测试性(Testability)
4. 性能(Performance)
5. 可扩展性(Scalability)
6. 易开发性(Ease of development)

# 1. 分层架构(Layered Architecture)

![](/img/jwblog/softArchi/figure1-1.png)

如**Figure 1-1**所示，它是一个分层架构的模型图，分层架构，顾名思义，应用的结构是一个层级结构，架构中的每一层有其对应的角色和责任。多数分层架构由四个标准的层定义：表示层(presentation),事务层(business),持久层(persistence)和存储层(database)。每一层皆有其对应的角色和责任，例如，表示层将处理与用户的交互，提供一个操作接口给用户；事务层将执行与与用户请求有关的业务逻辑。每一层只需要完成该层相关的业务逻辑，并不需要涉及其他层的业务，这将软件的功能和架构中的层结合起来，层与层之间不会产生事务逻辑上的重叠，层与层之间是相互独立的，修改某一层的逻辑，而不改变这一层提供给上一层的调用接口，将不会引起整个架构的更改。这使得应用很容易开发、调试、管理和维护。

![](/img/jwblog/softArchi/figure1-2.png)

*closed*是一个很重要的概念，如**Figure 1-2**所示，架构中的每一层都被标记为*closed*。*closed*的层表示，对于一个请求信息流而言，它必须一层接一层的向下传递，而不能跨层传递，比如，不允许表示层直接访问持久层。之所以不允许跨层访问是因为**层的隔离性(isolation)**。层的隔离性意味着架构中某一层的改变不会影响到其他层：这个改变被隔离了。如果让表示层可以直接访问持久层，那么对持久层的修改将会影响它的上层事务层和表示层，这将造成非常紧密的耦合关系，使得修改架构的代价变得及其昂贵。

![](/img/jwblog/softArchi/figure1-3.png)

封闭的层(*closed*)能有效的保证层与层之间的隔离性，但是对于某些应用场景，比如说，需要添加一个*共享服务层*到架构中，如**Figure 1-3**所示，在事务层的下面添加一个服务层，按照*closed*的概念，事务层将无法直接访问持久层，必须通过服务层来实现对持久层的访问。但是，事务层直接访问持久层能提升效率，通过某些中间层来实现访问是完全没有道理的，此时可以通过将新添加的服务层标记为*open*，这意味着来自上层的请求可以主动选择是否绕过该服务层，直接对其下面的层进行访问。这样就可以使事务层屏蔽掉服务层，然后直接对持久层进行访问。通过合理配置每层的*open*或*closed*状态。

![](/img/jwblog/softArchi/figure1-4.png)

如**Figure 1-4**所示，考虑一个用户请求的处理流程。黑线表示请求数据流方向，红线表示反馈数据流方向。首先是表示层，*custommer screen*模块负责接收请求和为用户提供一个展示界面，一旦它接收到一条请求，就将这条请求信息转发给*customer delegate*模块；*customer delegate*负责将用户的请求和事务层中模块关联起来，它能使每条请求数据包找到对应的在事务层的处理模块，类似于一个路由转发器；*customer object*负责收集汇总与构建事务层的请求数据包有关用户请求信息；*customer dao*，即*data access object*，负责通过某种方式(SQL)与持久层交互，获取用户想要的数据，反馈这些数据给事务层。

#### 80-20准则
80-20准则是指在正常情况下，大约有20%的访问请求是不需要进行具体的业务逻辑处理的，而剩下的80%的请求是需要通过相关的业务逻辑处理的。如果发现，在实际情况中，这个比率是反过来的，也就是说，大部分的请求是简单请求，不需要业务逻辑处理，那就需要将某些层设置为*open*状态。

# 2. 事件驱动架构(Event-Driven Architecture)
事件驱动架构是一种流行的用于开发高可扩展应用软件的分布式异步架构。它有两种不同的架构组织方案，分别是*mediator*和*broker*。*mediator*和*broker*之间最大的区别就在于是否存在一个中心事件调度转发单元。
#### 2.1 Mediator Topology

![](/img/jwblog/softArchi/figure2-1.png)

**Mediator**架构方案适用于需要为事件编排一个处理流程的应用场景。它需要一个中间件，这个中间件负责实现事件处理流程的处理和分发。如**Figure 2-1**所示，它有四个主要的组成部件：事件队列(event queues)、事件中间件(event mediator)、事件通道(event channels)和事件处理单元(event processors)。当某个客户端发送一个事件到事件队列，事件队列负责接收客户端发送过来的事件，并将这些事件转发给事件中间件；事件中间件接收这个初始事件，通过向多个事件通道发送额外的异步事件来构建针对这个初始事件的处理流程，这个过程被称为**初始事件的编排过程(orchestrates)**;事件处理单元监听其对应的事件通道，一旦事件通道中有事件传送进来，事件处理单元将执行指定的业务逻辑来处理这个事件。

它有两种不同类型的事件类型：初始事件(initial event)和业务事件(processing event)。初始事件是从客户端接收过来的原始未经处理的事件，业务事件是指由事件中间件生成的异步事件，这些异步事件将会被事件处理单元接收和处理。

事件通道用来传送有事件中间件产生的异步事件，它一般是一个按事件主题分类的消息队列，这样一个事件通道可以分配给多个事件处理单元。事件处理单元包含处理业务事件的业务逻辑，每一个事件处理单元都是独立的，只处理一个简单的业务逻辑且不依赖其他的事件处理单元来完成自身的业务逻辑处理任务。

事件中间件最简单和最广泛的实现方案是开源的集成中心(integration hubs)，例如Spring Integration，Apache Camel和Mule ESB。任何基于Mediator事件驱动架构的应用的成功应该建立在理性分析业务需求且将这些需求和正确的事件中间件实现方案匹配起来的基础上。

![](/img/jwblog/softArchi/figure2-2.png)

举一个例子来更好的理解Mediator事件驱动架构。假设你在一家保险公司投保完，已经决定离开这家公司。针对这种情况，初始事件可以称作*relocation event*，处理这个初始事件的步骤被描述在**Figure 2-2**中。事件中间件将这个事件转化为一个处理流程，流程的每一个步骤皆由一个业务事件驱动，事件中间件通过创建业务事件，并将该业务事件传送给相关的事件通道来驱动每个步骤下的事件处理单元来处理事件。当所有的事件处理单元处理完毕后，初始事件的流程也就结束了。

#### 2.2 Broker Topology
**Broker**架构方案不需要一个事件中间件，相反，消息流会流过所有的事件处理单元。该架构方案适用于不需要对初始事件重新编排的应用场景，只需要维护一个简单的事件处理流程。

![](/img/jwblog/softArchi/figure2-3.png)

如**Figure 2-3**所示，该架构方案并没有一个事件中间件来编排初始事件。事件处理单元只对传给该事件处理单元的事件负责，在执行完本处理单元的业务逻辑之后，产生一个新的事件，表示本单元的操作已经完成。

![](/img/jwblog/softArchi/figure2-4.png)

举例说明**Broker**是如何工作的，如前面提到的，你将要从保险公司离开，这个事件为初始事件，由于没有事件中间件来接收初始事件，客户端事件处理单元(Customer Process)将直接接收初始事件，它将改变用户的地址，然后产生一条新的消息，告知下面的事件处理单元*用户地址已经改变*。接下来，*quote process* 和 *claim process*这两个事件处理单元皆对这条新产生的事件感兴趣。他们也是在执行完自己的业务逻辑后，发送一条*事务完成*的事件消息给下面的处理单元进行处理。理解这种架构方案的最好方式就是将其看成是一场接力赛跑，每个事件处理单元就是每一个接力参赛者，每个人只跑一段距离，然后将接力棒交给下一个人。

#### Consideration
事件驱动架构是一个相对要复杂得多的模型，且由于异步分发的性质，导致其很难实现。例如，当远端的处理单元准备好处理事件时，需要一种消息机制，通知消息队列，传送一条事件消息，类似于生产者与消费者问题。另外，事件处理单元是高解耦和分布式部署的，维护这样一组转换单元是及其困难的。

# 3. 微内核架构
**微内核架构**是一种基于产品的应用开发模式，有时也被称为"插件架构模式"。它允许开发者可以向添加插件一样为软件的核心应用增添功能。微内核架构由两部分组成：核心系统(*core system*)和插件模块(*plug-in modules*)。应用软件的逻辑被分为核心系统和插件模块两部分。

![](/img/jwblog/softArchi/figure3-1.png)

**Figure 3-1**展示了一个基本的微内核架构模式。核心系统通常是指满足支持系统运转需要的最小功能单元的集合。插件模块是独立的，不依赖于其他模块的，用于实现特定功能的事务逻辑单元。它能扩展核心系统的功能，也就是能扩展整个应用软件的功能。核心系统需要知道那个插件模块是可用的，且知道怎样去调用这个插件。最常用的方式是将每个插件模块提供一个注册项，包含调用插件的一些必要的信息，如名称、地址、通信协议等等，具体的实现依赖于插件模块连接到核心系统的方式。

插件模块连接到核心系统的方式有很多，如OSGi(open, service gateway initiative)、消息(messaging)、web服务，或者就是直接的点对点的绑定(point-to-point binding)。

# 4. 微服务架构

![](/img/jwblog/softArchi/figure4-1.png)

关于微服务架构，有几个通用的概念。一是**separately deployed units**，如**Figure 4-1**所示，微服务架构的每一个组件都被部署为一个分离的单元。这些分离的单元，通过高效的流线型的输送管道，可以更容易的部署。二是**service component**，服务组件的概念范围很大，小到一个模块，大到应用软件大部分的功能部分。服务组件可以是只有一个或多个模块组成的表达某个单一功能或者是一个大型应用程序独立的部分，如何设计好服务组件的层级划分标准，是微服务架构的一个大难题。三是**distributed architecture**，这意味着微服务架构中的所有组件都是完全解耦的，互相之间通过某种远程访问协议进行访问，比如(JMS,AMQP,REST,SOAP,RMI)。

微服务架构有三种流行通用的构建逻辑：**API REST-based**、**application REST-based**和**centralized messaging**。

![](/img/jwblog/softArchi/figure4-2.png)

**API REST-based**布局方案，如**Figure 4-2**所示，由许多细粒度的服务组件构成(因而称为*微服务*)，通过一个基于web的API层提供的REST-based接口来访问各个服务组件。

![](/img/jwblog/softArchi/figure4-3.png)

**application REST-based**布局方案与**API REST-based**布局方案不同，它通过传统的基于web的或者就是一个直接的商业应用客户端来接收客户端请求，而**API REST-based**布局方案仅仅依靠一个简单的API层来完成交互。

![](/img/jwblog/softArchi/figure4-4.png)

**centralized messaging**布局方案使用一个轻量级的**centralized message broker** (ActiveMQ, HornetQ)来完成远程访问各个服务组件。
